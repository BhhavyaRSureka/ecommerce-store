// ********RoostGPT********
/*
Test generated by RoostGPT for test NodeMochaTest using AI Type Open AI and AI Model gpt-4-1106-preview


ROOST_TEST_HASH=4be4422950

*/

// ********RoostGPT********
const express = require("express");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const { loginValidation } = require("../validation"); // Adjust path as per project structure
const User = require("../model/User"); // Adjust path as per project structure
const request = require("supertest");
jest.mock("../validation");
jest.mock("../model/User");

describe('POST /login', () => {
  let server;

  beforeAll(() => {
    server = express();
    server.use(express.json());
    server.post("/login", async (req, res) => {
      const { error } = loginValidation(req.body);
      if (error) {
        return res.status(400).send(error.details[0].message);
      }
      const isUserExist = await User.findOne({ email: req.body.email });
      if (!isUserExist) {
        return res.status(400).send({ msg: "user does not exist" });
      }
      const validPass = await bcrypt.compare(req.body.password, isUserExist.password);
      if (!validPass) {
        return res.status(400).send("email or password wrong");
      }
      const token = jwt.sign({ _id: isUserExist._id }, process.env.SECRET_KEY);
      res.header("auth-token", token).send({
        token,
        user: isUserExist
      });
    });
  });

  afterAll(() => {
    server.close();
  });

  test('should return 400 if validation fails', async () => {
    // Mock the loginValidation function to simulate a validation error
    loginValidation.mockReturnValue({ error: { details: [{ message: "Validation error" }] } });

    const response = await request(server)
      .post('/login')
      .send({ email: "invalid-email", password: "short" });
    
    expect(response.status).toBe(400);
    expect(response.text).toBe("Validation error");
  });

  test('should return 400 if user does not exist', async () => {
    // Mock the User.findOne function to simulate user not found
    User.findOne.mockResolvedValue(null);

    const response = await request(server)
      .post('/login')
      .send({ email: "nonexisting@example.com", password: "password123" });
    
    expect(response.status).toBe(400);
    expect(response.body.msg).toBe("user does not exist");
  });

  test('should return 400 if password is incorrect', async () => {
    // Mock User.findOne to return a user and bcrypt.compare to return false
    User.findOne.mockResolvedValue({
      _id: "userId",
      email: "existing@example.com",
      password: "hashed-password"
    });
    bcrypt.compare.mockResolvedValue(false);

    const response = await request(server)
      .post('/login')
      .send({ email: "existing@example.com", password: "wrongpassword" });

    expect(response.status).toBe(400);
    expect(response.text).toBe("email or password wrong");
  });

  test('should return a valid token if credentials are correct', async () => {
    const mockUser = {
      _id: "userId",
      email: "user@example.com",
      password: "hashed-password"
    };

    // Mock User.findOne to return a user and bcrypt.compare to return true
    User.findOne.mockResolvedValue(mockUser);
    bcrypt.compare.mockResolvedValue(true);

    const response = await request(server)
      .post('/login')
      .send({ email: "user@example.com", password: "correctpassword" });

    expect(response.status).toBe(200);
    expect(response.body.token).toBeDefined();
    expect(response.body.user).toEqual(mockUser);
  });
});

