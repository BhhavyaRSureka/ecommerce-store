// ********RoostGPT********
/*
Test generated by RoostGPT for test NodeMochaTest using AI Type Open AI and AI Model gpt-4-1106-preview


ROOST_TEST_HASH=3dfdebf349

*/

// ********RoostGPT********
const express = require("express");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const { MongoMemoryServer } = require('mongodb-memory-server');
const mongoose = require('mongoose');
const supertest = require("supertest");
const User = require("../model/User"); // Modify as per directory structure
const { registerValidation } = require("../validation"); // Modify as per directory structure

let mongoServer;
beforeAll(async () => {
    mongoServer = await MongoMemoryServer.create();
    const mongoUri = mongoServer.getUri();
    await mongoose.connect(mongoUri);
});

afterAll(async () => {
    await mongoose.disconnect();
    await mongoServer.stop();
});

jest.mock('bcryptjs');
jest.mock('../model/User'); // Modify as per directory structure
jest.mock('../validation'); // Modify as per directory structure

describe('POST /register', () => {
  let app;
  let request;
  let userData;

  beforeAll(() => {
    app = express();
    app.use(express.json());
    app.post("/register", async (req, res) => {
      const { error } = registerValidation(req.body);
      if (error) {
        return res.status(400).send(error.details[0].message);
      }
      const isUserExist = await User.findOne({ email: req.body.email });
      if (isUserExist) {
        return res.status(400).send("user exist");
      }
      const salt = await bcrypt.genSalt(10);
      const hashPassword = await bcrypt.hash(req.body.password, salt);
      const newUser = {
        name: req.body.name,
        email: req.body.email,
        password: hashPassword
      };
      const user = new User(newUser);
      try {
        await user.save();
        res.status(200).send({ user: user._id });
      } catch (error) {
        res.status(400).send(error);
      }
    });

    request = supertest(app);
  });

  beforeEach(() => {
    userData = {
      name: 'John Doe',
      email: 'john@example.com',
      password: '123456'
    };

    registerValidation.mockReturnValue({ error: null });
    bcrypt.genSalt.mockResolvedValue('fakeSalt');
    bcrypt.hash.mockResolvedValue('fakeHashedPassword');
    User.findOne.mockResolvedValue(null);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  test('should register a new user when all input is valid', async () => {
    User.prototype.save = jest.fn().mockResolvedValue({
      _id: 'testUserId',
      ...userData,
      password: 'fakeHashedPassword'
    });

    const response = await request.post("/register").send(userData);

    expect(response.statusCode).toBe(200);
    expect(response.body).toEqual({ user: 'testUserId' });
  });

  test('should return 400 status if validation fails', async () => {
    registerValidation.mockReturnValue({
      error: { details: [{ message: 'Invalid input' }] }
    });

    const response = await request.post("/register").send(userData);

    expect(response.statusCode).toBe(400);
    expect(response.text).toBe('Invalid input');
  });

  test('should return 400 status if user already exists', async () => {
    User.findOne.mockResolvedValue({
      _id: 'testExistingUserId',
      ...userData
    });
    
    const response = await request.post("/register").send(userData);

    expect(response.statusCode).toBe(400);
    expect(response.text).toBe('user exist');
  });

  test('should return 400 status if there is an error saving user', async () => {
    User.prototype.save = jest.fn().mockRejectedValue(new Error('Save error'));

    const response = await request.post("/register").send(userData);

    expect(response.statusCode).toBe(400);
    expect(response.text).toEqual(expect.stringContaining('Save error'));
  });
});

