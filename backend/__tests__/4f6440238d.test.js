// ********RoostGPT********
/*
Test generated by RoostGPT for test NodeMochaTest using AI Type Open AI and AI Model gpt-4-1106-preview


ROOST_TEST_HASH=ed3de449ff

*/

// ********RoostGPT********
const express = require("express");
const request = require("supertest");
const passport = require("passport");
const { Strategy, ExtractJwt } = require("passport-jwt");
const jwt = require("jsonwebtoken");
const router = require("../routes/users");
jest.mock('../../models/User', () => {
  return jest.fn().mockImplementation(() => {
    return {
      save: jest.fn().mockResolvedValue(true),
    };
  });
});
jest.mock('passport', () => {
  const originalPassport = jest.requireActual('passport');
  return {
    ...originalPassport,
    authenticate: jest.fn((strategy, options) => (req, res, next) => {
      req.user = { id: "test_id", name: "test_name", email: "test_email" };
      next();
    }),
  };
});
const app = express();
app.use(express.json());
app.use(passport.initialize());
app.use('/api/users', router);
describe('GET /current user', () => {
  let agent;
  beforeAll(() => {
    passport.use(new Strategy({
      secretOrKey: 'secret',
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken()
    }, (jwt_payload, done) => {
      if (jwt_payload.id === 'test_id') {
        return done(null, { id: "test_id", name: "test_name", email: "test_email" });
      } else {
        return done(null, false);
      }
    }));
    agent = request.agent(app);
  });
  test('should return the current user when authenticated', async () => {
    const response = await agent.get('/api/users/current')
      .set('Authorization', 'Bearer correct_token');
    expect(response.statusCode).toBe(200);
    expect(response.body).toEqual({
      id: "test_id",
      name: "test_name",
      email: "test_email"
    });
  });
  test('should return unauthorized if not authenticated', async () => {
    const response = await agent.get('/api/users/current')
      .set('Authorization', 'Bearer incorrect_token');
    expect(response.statusCode).toBe(401);
    expect(response.body).not.toHaveProperty('id');
    expect(response.body).not.toHaveProperty('name');
    expect(response.body).not.toHaveProperty('email');
  });
});

