// ********RoostGPT********
/*
Test generated by RoostGPT for test NodeMochaTest using AI Type Open AI and AI Model gpt-4-1106-preview


ROOST_TEST_HASH=4be4422950

*/

// ********RoostGPT********
// Assuming that the structure is as follows:
// - root
// |-- backend
//     |-- __tests__
//         |-- auth.test.js
//     |-- routes
//         |-- auth.js

const express = require("express");
const router = express.Router();
// Since test file and actual file are in same folder use relative path '../routes/auth'
const User = require("../models/User"); // Fix the path to '../models/User'
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const { loginValidation } = require("../validation");
const supertest = require("supertest");
const app = express();
app.use(express.json());
// Import actual router with: const auth = require("../routes/auth");
app.use(auth); // Use 'auth' router here

// The other required change is the installation of Jest. However, here is the updated test case

// Set up our test suite
describe("POST /login", () => {
  let user;

  // Setup a user and token before each test
  beforeEach(() => {
    user = {
      _id: "123456",
      email: "test@example.com",
      password: "hashedpassword",
      name: "Test User"
    };
    // Mock the User.findOne method
    User.findOne = jest.fn().mockResolvedValue(user);
    // Mock bcrypt.compare to always return true
    bcrypt.compare = jest.fn().mockResolvedValue(true);
    // Mock jwt.sign method
    jwt.sign = jest.fn().mockReturnValue("testtoken");
  });

  test("should login successfully and return auth token", async () => {
    const response = await supertest(app)
      .post("/login")
      .send({ email: user.email, password: "password" });

    expect(response.statusCode).toBe(200);
    expect(response.headers['auth-token']).toBe("testtoken");
    expect(response.body).toEqual({
      token: "testtoken",
      user: {
        _id: user._id,
        email: user.email,
        name: user.name
      }
    });
  });

  test("should return 400 if validation fails", async () => {
    // Mock loginValidation to simulate a validation error
    const validationError = {
      details: [{ message: "Invalid email or password." }]
    };
    loginValidation.mockReturnValue({ error: validationError });

    const response = await supertest(app)
      .post("/login")
      .send({ email: "invalid", password: "password" });

    expect(response.statusCode).toBe(400);
    expect(response.text).toBe(validationError.details[0].message);
  });

  test("should return 400 if user does not exist", async () => {
    // Simulate user not found
    User.findOne.mockResolvedValue(null);

    const response = await supertest(app)
      .post("/login")
      .send({ email: "notexist@example.com", password: "password" });

    expect(User.findOne).toHaveBeenCalledWith({ email: "notexist@example.com" });
    expect(response.statusCode).toBe(400);
    expect(response.body.msg).toBe("User does not exist."); // Capitalize the first letter
  });

  test("should return 400 if password is wrong", async () => {
    // Simulate wrong password
    bcrypt.compare.mockResolvedValue(false);

    const response = await supertest(app)
      .post("/login")
      .send({ email: user.email, password: "wrongpassword" });

    expect(response.statusCode).toBe(400);
    expect(response.text).toBe("Email or password is wrong."); // Provide a clearer message
  });

  afterEach(() => {
    // reset the mocks after each test
    jest.resetAllMocks();
  });
});

