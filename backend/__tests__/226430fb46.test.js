// ********RoostGPT********
/*
Test generated by RoostGPT for test NodeTesting using AI Type Open AI and AI Model gpt-4-1106-preview

ROOST_METHOD_HASH=3dfdebf349
ROOST_METHOD_SIG_HASH=226430fb46


*/

// ********RoostGPT********
const express = require("express");
const User = require("../model/User");
const bcrypt = require("bcryptjs");
const { registerValidation } = require("../validation");

describe('/register route', () => {
  let app, server, request;

  beforeAll(async () => {
    app = express();
    app.use(express.json()); // Body parser
    app.post("/register", async (req, res) => {
      const { error } = registerValidation(req.body);
      if (error) {
        return res.status(400).send(error.details[0].message);
      }
      const isUserExist = await User.findOne({ email: req.body.email });
      if (isUserExist) {
        return res.status(400).send("user exist");
      }
      const salt = await bcrypt.genSalt(10);
      const hashPassword = await bcrypt.hash(req.body.password, salt);
      const newUser = {
        name: req.body.name,
        email: req.body.email,
        password: hashPassword
      };
      const user = new User(newUser);
      try {
        await user.save();
        res.status(200).send({ user: user._id });
      } catch (error) {
        res.status(400).send(error);
      }
    });

    server = app.listen(5000);
    request = require('supertest');
  });

  afterAll(async () => {
    await server.close(); // Close the server after tests
  });

  // Mock User.findOne() and User.prototype.save functions
  beforeEach(() => {
    User.findOne = jest.fn();
    User.prototype.save = jest.fn();
  });

  test('should return 200 when user is correctly registered', async () => {
    // Mock user not found
    User.findOne.mockResolvedValue(null);
    User.prototype.save.mockResolvedValue({ _id: 'userId' });

    const response = await request(app)
      .post("/register")
      .send({
        name: 'Test User',
        email: 'testuser@example.com',
        password: 'password123'
      });
    expect(response.statusCode).toBe(200);
    expect(response.body.user).toBeDefined();
  });

  test('should return 400 if user already exists', async () => {
    // Mock user found
    User.findOne.mockResolvedValue(true);

    const response = await request(app)
      .post("/register")
      .send({
        name: 'Test User',
        email: 'testuser@example.com',
        password: 'password123'
      });
    expect(response.statusCode).toBe(400);
    expect(response.text).toBe("user exist");
  });

  test('should return 400 with validation errors', async () => {
    // Send an invalid email
    const response = await request(app)
      .post("/register")
      .send({
        name: 'Test User',
        email: 'not-an-email',
        password: 'password123'
      });
    expect(response.statusCode).toBe(400);
    // Specify the error message expected from the validation function
    expect(response.text).toContain('email must be a valid email');
  });

  test('should return 400 when there is a database error', async () => {
    // Mock user not found but simulate error on save
    User.findOne.mockResolvedValue(null);
    const errorMessage = "Database error on save";
    User.prototype.save.mockRejectedValue(new Error(errorMessage));

    const response = await request(app)
      .post("/register")
      .send({
        name: 'Test User',
        email: 'testuser@example.com',
        password: 'password123'
      });
    expect(response.statusCode).toBe(400);
    expect(response.text).toBe(errorMessage);
  });

});

