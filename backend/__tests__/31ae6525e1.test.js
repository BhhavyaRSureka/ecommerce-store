// ********RoostGPT********
/*
Test generated by RoostGPT for test NodeMochaTest using AI Type Open AI and AI Model gpt-4-1106-preview


ROOST_TEST_HASH=4be4422950

*/

// ********RoostGPT********
const express = require("express");
const User = require("../model/User");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const { loginValidation } = require("../validation");

// Simulating environment variables
process.env.SECRET_KEY = 'test_secret_key';

describe('/login route', () => {
  const mockSend = jest.fn();
  const mockStatus = jest.fn().mockReturnValue({ send: mockSend });
  const mockRes = { status: mockStatus, header: jest.fn().mockReturnThis() };
  const mockUserFindOne = jest.fn();
  const mockBcryptCompare = jest.fn();
  const mockJwtSign = jest.fn();

  beforeAll(() => {
    User.findOne = mockUserFindOne;
    bcrypt.compare = mockBcryptCompare;
    jwt.sign = mockJwtSign;
  });

  beforeEach(() => {
    mockSend.mockClear();
    mockStatus.mockClear();
    mockRes.header.mockClear();
    mockUserFindOne.mockClear();
    mockBcryptCompare.mockClear();
    mockJwtSign.mockClear();
  });

  test('returns 400 if validation fails', async () => {
    const req = {
      body: {
        email: "invalid-email", // Invalid email for the purpose of the test
        password: "123456"
      }
    };
    await require('../routes/auth').post(req, mockRes);
    expect(mockStatus).toHaveBeenCalledWith(400);
    expect(mockSend).toHaveBeenCalled();
  });

  test('returns 400 if user does not exist', async () => {
    const req = {
      body: {
        email: "user@example.com",
        password: "123456"
      }
    };

    mockUserFindOne.mockResolvedValue(null);

    await require('../routes/auth').post(req, mockRes);
    expect(mockUserFindOne).toHaveBeenCalledWith({ email: req.body.email });
    expect(mockStatus).toHaveBeenCalledWith(400);
    expect(mockSend).toHaveBeenCalledWith({ msg: "user does not exist" });
  });

  test('returns 400 if password is incorrect', async () => {
    const req = {
      body: {
        email: "user@example.com",
        password: "wrongpassword"
      }
    };
    const user = { _id: "someUserId", password: "$2a$12$examplehash" };

    mockUserFindOne.mockResolvedValue(user);
    mockBcryptCompare.mockResolvedValue(false);

    await require('../routes/auth').post(req, mockRes);
    expect(mockBcryptCompare).toHaveBeenCalledWith(req.body.password, user.password);
    expect(mockStatus).toHaveBeenCalledWith(400);
    expect(mockSend).toHaveBeenCalledWith("email or password wrong");
  });

  test('responds with auth token if login is successful', async () => {
    const req = {
      body: {
        email: "user@example.com",
        password: "correctpassword"
      }
    };
    const user = { _id: "someUserId", password: "$2a$12$examplehash" };
    const token = "someAuthToken";

    mockUserFindOne.mockResolvedValue(user);
    mockBcryptCompare.mockResolvedValue(true);
    mockJwtSign.mockReturnValue(token);

    await require('../routes/auth').post(req, mockRes);
    expect(mockJwtSign).toHaveBeenCalledWith({ _id: user._id }, process.env.SECRET_KEY);
    expect(mockRes.header).toHaveBeenCalledWith("auth-token", token);
    expect(mockSend).toHaveBeenCalledWith({ token, user });
  });
});

