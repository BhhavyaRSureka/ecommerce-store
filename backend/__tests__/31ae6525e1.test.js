// ********RoostGPT********
/*
Test generated by RoostGPT for test NodeTesting using AI Type Open AI and AI Model gpt-4-1106-preview

ROOST_METHOD_HASH=4be4422950
ROOST_METHOD_SIG_HASH=31ae6525e1


*/

// ********RoostGPT********
const express = require("express");

// Mock dependencies
jest.mock("bcryptjs", () => ({
  compare: jest.fn(),
}));
jest.mock("jsonwebtoken", () => ({
  sign: jest.fn(),
}));
jest.mock("../model/User", () => ({
  findOne: jest.fn(),
}));
jest.mock("../validation", () => ({
  registerValidation: jest.fn(),
  loginValidation: jest.fn(),
}));

// Import dependencies after mocking
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const { registerValidation, loginValidation } = require("../validation");
const User = require("../model/User");

describe('/api/user/login route', () => {
  let app;
  let router;

  beforeEach(() => {
    app = express();
    router = express.Router();
    app.use(express.json());
    app.use('/api/user', router);
    require('../routes/auth')(router);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should respond with 400 if validation fails', async () => {
    const req = { body: { email: 'invalidemail', password: '123456' } };
    const res = { status: jest.fn().mockReturnThis(), json: jest.fn() };
    loginValidation.mockReturnValue({ error: { details: [{ message: "Invalid email" }] } });

    await router.handle(req, res);

    expect(loginValidation).toHaveBeenCalledWith(req.body);
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.json).toHaveBeenCalledWith({ error: "Invalid email" });
  });

  it('should respond with 400 if user does not exist', async () => {
    const req = { body: { email: 'test@example.com', password: '123456' } };
    const res = { status: jest.fn().mockReturnThis(), json: jest.fn() };
    loginValidation.mockReturnValue({});
    User.findOne.mockResolvedValue(null);

    await router.handle(req, res);

    expect(User.findOne).toHaveBeenCalledWith({ email: req.body.email });
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.json).toHaveBeenCalledWith({ error: "User does not exist" });
  });

  it('should respond with 400 if password is incorrect', async () => {
    const req = { body: { email: 'test@example.com', password: 'wrongpassword' } };
    const res = { status: jest.fn().mockReturnThis(), json: jest.fn() };
    const user = { _id: 'some_id', email: 'test@example.com', password: 'hashedpassword' };

    loginValidation.mockReturnValue({});
    User.findOne.mockResolvedValue(user);
    bcrypt.compare.mockResolvedValue(false);

    await router.handle(req, res);

    expect(bcrypt.compare).toHaveBeenCalledWith(req.body.password, user.password);
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.json).toHaveBeenCalledWith({ error: "Invalid password" });
  });

  it('should send token if email and password are correct', async () => {
    const req = { body: { email: 'test@example.com', password: 'correctpassword' } };
    const res = { header: jest.fn().mockReturnThis(), send: jest.fn() };
    const user = { _id: 'some_id', email: 'test@example.com', password: 'hashedpassword' };

    loginValidation.mockReturnValue({});
    User.findOne.mockResolvedValue(user);
    bcrypt.compare.mockResolvedValue(true);
    jwt.sign.mockReturnValue('generated_token');

    await router.handle(req, res);

    expect(bcrypt.compare).toHaveBeenCalledWith(req.body.password, user.password);
    expect(jwt.sign).toHaveBeenCalledWith({ _id: user._id }, process.env.SECRET_KEY, { expiresIn: '1h' });
    expect(res.header).toHaveBeenCalledWith("auth-token", 'generated_token');
    expect(res.send).toHaveBeenCalledWith({
      token: 'generated_token',
      user: { email: user.email, _id: user._id }
    });
  });

  // Mock express router handler
  router.handle = (req, res) => {
    const { email, password } = req.body;
    const validation = loginValidation(req.body);
    if (validation.error) {
      return res.status(400).json({ error: validation.error.details[0].message });
    }

    const user = User.findOne({ email });
    if (!user) {
      return res.status(400).json({ error: "User does not exist" });
    }
    
    const passwordMatch = bcrypt.compare(password, user.password);
    if (!passwordMatch) {
      return res.status(400).json({ error: "Invalid password" });
    }
    
    const token = jwt.sign({ _id: user._id }, process.env.SECRET_KEY, { expiresIn: '1h' });
    res.header("auth-token", token).send({
      token,
      user: { email: user.email, _id: user._id }
    });
  };
});

