// ********RoostGPT********
/*
Test generated by RoostGPT for test NodeTesting using AI Type Open AI and AI Model gpt-4-1106-preview

ROOST_METHOD_HASH=3dfdebf349
ROOST_METHOD_SIG_HASH=226430fb46


*/

// ********RoostGPT********
const express = require("express");
const request = require("supertest");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const { MongoMemoryServer } = require("mongodb-memory-server");
const mongoose = require("mongoose");
const { registerValidation } = require("../../validation");
const User = require("../../model/User");

let mongoServer;

beforeAll(async () => {
  mongoServer = await MongoMemoryServer.create();
  await mongoose.connect(mongoServer.getUri(), { useNewUrlParser: true, useUnifiedTopology: true });
});

afterAll(async () => {
  await mongoose.disconnect();
  await mongoServer.stop();
});

jest.mock("bcryptjs", () => ({
  genSalt: () => "fake_salt",
  hash: () => "hashed_password",
}));

const app = express();
app.use(express.json());
app.post("/register", async (req, res) => {
  const { error } = registerValidation(req.body);
  if (error) {
    return res.status(400).send(error.details[0].message);
  }
  const isUserExist = await User.findOne({ email: req.body.email });
  if (isUserExist) {
    return res.status(400).send("user exist");
  }
  const salt = await bcrypt.genSalt(10);
  const hashPassword = await bcrypt.hash(req.body.password, salt);
  const newUser = new User({
    name: req.body.name,
    email: req.body.email,
    password: hashPassword
  });
  try {
    await newUser.save();
    res.status(200).send({ user: newUser._id });
  } catch (error) {
    res.status(400).send(error);
  }
});

describe('POST /register', () => {
  test('should register a new user with valid data', async () => {
    const res = await request(app)
      .post('/register')
      .send({
        name: 'John Doe',
        email: 'john@example.com',
        password: 'password123'
      });
    
    expect(res.statusCode).toBe(200);
    expect(res.body).toHaveProperty('user');
  });

  test('should not register a user with existing email', async () => {
    await new User({
      name: 'Existing User',
      email: 'existing@example.com',
      password: 'hashed_password'
    }).save();

    const res = await request(app)
      .post('/register')
      .send({
        name: 'Test User',
        email: 'existing@example.com',
        password: 'password123'
      });

    expect(res.statusCode).toBe(400);
    expect(res.text).toEqual("user exist");
  });

  test('should not register a user with invalid data', async () => {
    const res = await request(app)
      .post('/register')
      .send({
        name: 'Jane Doe',
        password: 'password123'
      });
    
    expect(res.statusCode).toBe(400);
    expect(res.text).toBeTruthy();
  });
});

