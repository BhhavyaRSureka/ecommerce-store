// ********RoostGPT********
/*
Test generated by RoostGPT for test NodeMochaTest using AI Type Open AI and AI Model gpt-4-1106-preview


ROOST_TEST_HASH=4be4422950

*/

// ********RoostGPT********
const express = require("express");
const app = express();
const User = require("../../routes/model/User");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const { loginValidation } = require("../../routes/validation");
const dotenv = require("dotenv");
dotenv.config();

jest.mock("bcryptjs");
jest.mock("jsonwebtoken");
jest.mock("../../routes/model/User");
jest.mock("../../routes/validation");

describe("POST /login", () => {
  let mockUser;

  beforeAll(() => {
    // Set up database connections or shared resources here
  });

  beforeEach(() => {
    mockUser = {
      _id: "mockUserId",
      name: "John Doe",
      email: "john@example.com",
      password: "hashedpassword"
    };
    User.findOne = jest.fn();
    bcrypt.compare = jest.fn();
    jwt.sign = jest.fn();
    loginValidation.mockReturnValue({ value: true });
  });

  afterEach(() => {
    // Clean up after each test case
    jest.clearAllMocks();
  });

  afterAll(() => {
    // Clean up any remaining resources or connections
  });

  test("should return 400 if validation fails", async () => {
    const req = {
      body: {
        email: "john@example.com",
        password: "123456"
      }
    };
    const res = {
      status: jest.fn(() => res),
      send: jest.fn()
    };
    // Simulate validation error
    loginValidation.mockReturnValueOnce({ error: { details: [{ message: "Invalid input" }] } });

    await User.loginUser(req, res);

    expect(loginValidation).toHaveBeenCalledWith(req.body);
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.send).toHaveBeenCalledWith("Invalid input");
  });

  test("should return 400 if user does not exist", async () => {
    const req = {
      body: {
        email: "john@example.com",
        password: "123456"
      }
    };
    const res = {
      status: jest.fn(() => res),
      send: jest.fn()
    };
    // Simulate user not found
    User.findOne.mockResolvedValue(null);

    await User.loginUser(req, res);

    expect(User.findOne).toHaveBeenCalled();
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.send).toHaveBeenCalledWith({ msg: "user does not exist" });
  });

  test("should return 400 if password is wrong", async () => {
    const req = {
      body: {
        email: "john@example.com",
        password: "wrongpassword"
      }
    };
    const res = {
      status: jest.fn(() => res),
      send: jest.fn()
    };

    User.findOne.mockResolvedValue(mockUser);
    bcrypt.compare.mockResolvedValue(false);

    await User.loginUser(req, res);

    expect(User.findOne).toHaveBeenCalled();
    expect(bcrypt.compare).toHaveBeenCalledWith("wrongpassword", mockUser.password);
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.send).toHaveBeenCalledWith("email or password wrong");
  });

  test("should return token if login is successful", async () => {
    const req = {
      body: {
        email: "john@example.com",
        password: "correctpassword"
      }
    };
    const res = {
      status: jest.fn(() => res),
      header: jest.fn(() => res),
      send: jest.fn()
    };
    const expectedToken = "someAuthToken";

    User.findOne.mockResolvedValue(mockUser);
    bcrypt.compare.mockResolvedValue(true);
    jwt.sign.mockReturnValue(expectedToken);

    await User.loginUser(req, res);

    expect(User.findOne).toHaveBeenCalled();
    expect(bcrypt.compare).toHaveBeenCalledWith("correctpassword", mockUser.password);
    expect(jwt.sign).toHaveBeenCalled();
    expect(res.header).toHaveBeenCalledWith("auth-token", expectedToken);
    expect(res.send).toHaveBeenCalledWith({
      token: expectedToken,
      user: mockUser
    });
  });
});

// loginUser function needs to be implemented in the User model
User.loginUser = async (req, res) => {
  // User model's login handling logic with mocked functions
};

