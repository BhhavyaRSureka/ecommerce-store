// ********RoostGPT********
/*
Test generated by RoostGPT for test NodeMochaTest using AI Type Open AI and AI Model gpt-4-1106-preview


ROOST_TEST_HASH=3dfdebf349

*/

// ********RoostGPT********
const express = require("express");
const mongoose = require("mongoose");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const { registerValidation } = require("../validation");
const router = express.Router();
const User = require("../model/User");

// Mock dependencies
jest.mock("bcryptjs");
jest.mock("../model/User");
jest.mock("../validation");

beforeAll(async () => {
  await mongoose.connect("mongodb://localhost/test", {
    useNewUrlParser: true,
    useUnifiedTopology: true
  });
});

afterAll(async () => {
  await mongoose.connection.close();
});

beforeEach(() => {
  // Reset the mocks before each test
  bcrypt.genSalt.mockReset();
  bcrypt.hash.mockReset();
  User.findOne.mockReset();
  User.mockClear();
  registerValidation.mockReset();
});

describe("/register endpoint", () => {
  test("should validate request body and return error if invalid", async () => {
    // Setup
    const req = { body: {} };
    const res = { status: jest.fn().mockReturnThis(), send: jest.fn() };
    const validationError = { details: [{ message: "Invalid request" }] };

    registerValidation.mockReturnValue({ error: validationError });

    // Execute
    await router.post("/register", async (req, res) => {
      // Handler logic here
    })(req, res);

    // Verify
    expect(registerValidation).toHaveBeenCalledWith(req.body);
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.send).toHaveBeenCalledWith(validationError.details[0].message);
  });

  test("should check if user exists and return error if user exists", async () => {
    // Setup
    const req = { body: { email: "test@example.com" } };
    const res = { status: jest.fn().mockReturnThis(), send: jest.fn() };

    registerValidation.mockReturnValue({});
    User.findOne.mockResolvedValue(true);

    // Execute
    await router.post("/register", async (req, res) => {
      // Handler logic here
    })(req, res);

    // Verify
    expect(User.findOne).toHaveBeenCalledWith({ email: req.body.email });
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.send).toHaveBeenCalledWith("user exist");
  });

  test("should create user if validation passed and user does not exist", async () => {
    // Setup
    const req = {
      body: {
        name: "Test User",
        email: "test@example.com",
        password: "password"
      }
    };
    const res = { status: jest.fn().mockReturnThis(), send: jest.fn() };
    const fakeSalt = "fake_salt";
    const fakeHashedPassword = "hashed_password";

    registerValidation.mockReturnValue({});
    User.findOne.mockResolvedValue(false);
    bcrypt.genSalt.mockResolvedValue(fakeSalt);
    bcrypt.hash.mockResolvedValue(fakeHashedPassword);
    
    const mockUser = new User();
    mockUser.save = jest.fn().mockResolvedValue(mockUser);

    // Execute
    await router.post("/register", async (req, res) => {
      // Handler logic here
    })(req, res);

    // Verify
    expect(registerValidation).toHaveBeenCalledWith(req.body);
    expect(User.findOne).toHaveBeenCalledWith({ email: req.body.email });
    expect(bcrypt.genSalt).toHaveBeenCalledWith(10);
    expect(bcrypt.hash).toHaveBeenCalledWith(req.body.password, fakeSalt);
    expect(mockUser.save).toHaveBeenCalled();
    expect(res.status).toHaveBeenCalledWith(200);
    expect(res.send).toHaveBeenCalledWith({ user: mockUser._id });
  });

  test("should return error if there is a database error", async () => {
    // Setup
    const req = {
      body: {
        name: "Test User",
        email: "test@example.com",
        password: "password"
      }
    };
    const res = { status: jest.fn().mockReturnThis(), send: jest.fn() };
    const dbError = new Error("DB error");

    registerValidation.mockReturnValue({});
    User.findOne.mockResolvedValue(false);
    bcrypt.genSalt.mockResolvedValue("fake_salt");
    bcrypt.hash.mockResolvedValue("hashed_password");

    const newUser = new User();
    newUser.save = jest.fn().mockRejectedValue(dbError);

    // Execute
    await router.post("/register", async (req, res) => {
      // Handler logic here
    })(req, res);

    // Verify
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.send).toHaveBeenCalledWith(dbError);
  });
});

module.exports = router;

