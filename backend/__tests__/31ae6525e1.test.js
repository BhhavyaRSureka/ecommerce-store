// ********RoostGPT********
/*
Test generated by RoostGPT for test NodeTesting using AI Type Open AI and AI Model gpt-4-1106-preview

ROOST_METHOD_HASH=4be4422950
ROOST_METHOD_SIG_HASH=31ae6525e1


*/

// ********RoostGPT********
const express = require("express");
const router = express.Router();
const User = jest.createMockFromModule("../model/User");
const bcrypt = jest.createMockFromModule("bcryptjs");
const jwt = require("jsonwebtoken");
const { loginValidation } = require("../validation");

// Jest Mocking Framework
jest.mock('../model/User');
jest.mock('bcryptjs');

describe("/POST login", () => {
  let user;

  beforeAll(() => {
    process.env.SECRET_KEY = "secret"; // Define environment variable for jwt
  });

  beforeEach(() => {
    // Set up mock user data before each test case
    user = {
      _id: "123456",
      email: "test@example.com",
      password: "hashedPassword",
    };
    // Reset the mocks before each test
    jest.resetAllMocks();
  });

  afterAll(() => {
    // Cleanup tasks after all tests have run
    jest.clearAllMocks();
    delete process.env.SECRET_KEY;
  });

  test("should fail when validation fails", async () => {
    const req = { body: { email: "test", password: "123456" } };
    const res = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
    };
    
    const { error } = loginValidation(req.body);
    await router.handle({ path: '/login', method: 'POST' }, req, res);
    
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.send).toHaveBeenCalledWith(error.details[0].message);
  });

  test("should fail when user does not exist", async () => {
    const req = { body: { email: "nouser@example.com", password: "123456" } };
    const res = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
    };

    User.findOne.mockResolvedValue(null);

    await router.handle({ path: '/login', method: 'POST' }, req, res);

    expect(User.findOne).toHaveBeenCalledWith({ email: req.body.email });
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.send).toHaveBeenCalledWith({ msg: "user does not exist" });
  });

  test("should fail when password is incorrect", async () => {
    const req = { body: { email: "test@example.com", password: "wrongPassword" } };
    const res = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
    };

    User.findOne.mockResolvedValue(user);
    bcrypt.compare.mockResolvedValue(false);

    await router.handle({ path: '/login', method: 'POST' }, req, res);

    expect(bcrypt.compare).toHaveBeenCalledWith(req.body.password, user.password);
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.send).toHaveBeenCalledWith("email or password wrong");
  });

  test("should succeed with a valid token when credentials are correct", async () => {
    const req = { body: { email: "test@example.com", password: "correctPassword" } };
    const res = {
      header: jest.fn().mockReturnThis(),
      send: jest.fn(),
    };

    User.findOne.mockResolvedValue(user);
    bcrypt.compare.mockResolvedValue(true);
    const token = jwt.sign({ _id: user._id }, process.env.SECRET_KEY);

    await router.handle({ path: '/login', method: 'POST' }, req, res);

    expect(bcrypt.compare).toHaveBeenCalledWith(req.body.password, user.password);
    expect(res.header).toHaveBeenCalledWith("auth-token", token);
    expect(res.send).toHaveBeenCalledWith({ token, user });
  });
});

