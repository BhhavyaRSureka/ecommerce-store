// ********RoostGPT********
/*
Test generated by RoostGPT for test NodeMochaTest using AI Type Open AI and AI Model gpt-4-1106-preview


ROOST_TEST_HASH=ed3de449ff

*/

// ********RoostGPT********
// tests/backend/__tests__/users.test.js
const request = require('supertest');
const express = require('express');
const passport = require('passport');
const jwt = require('jsonwebtoken');
const { Strategy } = require('passport-strategy');

// The relative path for required files based on the directory structure provided
const User = require('../../../models/User');
const router = require('../../routes/users'); // assuming the users.js is in the routes folder
const keys = require('../../../config/keys');

describe('/current endpoint', () => {
  let server;
  let userPayload;

  beforeAll(() => {
    server = express();
    server.use(express.json());
    server.use(passport.initialize()); // If passport is being used, it needs to be initialized

    // Mock the passport strategy used in the routes to always return a user
    class MockStrategy extends Strategy {
      constructor() {
        super();
        this.name = 'jwt';
      }

      authenticate(req, options) {
        return this.success(userPayload);
      }
    }

    passport.use(new MockStrategy());

    server.use('/', router);
  });

  beforeEach(() => {
    // This is a mocked user payload that would come from a database in a real application
    userPayload = {
      id: 'testUserId',
      name: 'TestUser',
      email: 'testuser@example.com',
    };
  });

  test('should return current user when provided a valid JWT token', async () => {
    const token = jwt.sign(userPayload, keys.secretOrKey, { expiresIn: 3600 });

    const response = await request(server)
      .get('/current')
      .set('Authorization', `Bearer ${token}`);

    expect(response.statusCode).toBe(200);
    expect(response.body).toMatchObject({
      id: userPayload.id,
      name: userPayload.name,
      email: userPayload.email,
    });
  });

  test('should return a 401 status if not authenticated', async () => {
    // Mock the passport strategy used in the routes to fail authentication
    class FailedStrategy extends Strategy {
      constructor() {
        super();
        this.name = 'jwt';
      }

      authenticate(req, options) {
        return this.fail(401);
      }
    }

    passport.unuse('jwt').use(new FailedStrategy());

    const response = await request(server).get('/current');

    expect(response.statusCode).toBe(401);
    expect(response.body).toMatchObject({ message: 'Unauthorized' });
  });

  afterAll(() => {
    // Close the server and perform clean-up tasks if necessary
    server.close();
  });
});

