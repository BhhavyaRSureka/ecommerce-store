// ********RoostGPT********
/*
Test generated by RoostGPT for test NodeMochaTest using AI Type Open AI and AI Model gpt-4-1106-preview


ROOST_TEST_HASH=3dfdebf349

*/

// ********RoostGPT********
const express = require("express");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const User = require("../model/User");
const { body, validationResult } = require("express-validator");
const supertest = require("supertest");

// Mocks
jest.mock("../model/User");
jest.mock("bcryptjs");

describe("Auth Router - Register Endpoint", () => {
  let server;
  let request;

  beforeAll(async () => {
    const app = express();
    app.use(express.json());

    // Validators
    const registerValidators = [
      body("name").notEmpty(),
      body("email").isEmail(),
      body("password").isLength({ min: 6 }),
    ];

    // Auth route
    app.post("/auth/register", registerValidators, async (req, res) => {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
      }

      const { name, email, password } = req.body;
      try {
        let user = await User.findOne({ email });
        if (user) {
          return res.status(400).send("User already exists");
        }

        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(password, salt);

        user = new User({ name, email, password: hashedPassword });

        await user.save();

        const payload = { user: { id: user.id } };

        jwt.sign(payload, "secret", { expiresIn: 360000 }, (err, token) => {
          if (err) throw err;
          res.json({ token });
        });
      } catch (err) {
        console.error(err.message);
        res.status(500).send("Server Error");
      }
    });

    server = app.listen(4000, () => console.log('Server started on port 4000'));
    request = supertest(server);
  });

  afterAll(() => {
    server.close();
  });

  beforeEach(() => {
    User.findOne.mockReset();
    bcrypt.genSalt.mockReset();
    bcrypt.hash.mockReset();
  });

  test("should return 400 if validation fails", async () => {
    const user = {
      name: "Test User",
      email: "invalid_email",
      password: "password",
    };
    const response = await request.post("/auth/register").send(user);
    expect(response.status).toBe(400);
    expect(response.body).toHaveProperty("errors");
  });

  test("should return 400 if user already exists", async () => {
    User.findOne.mockResolvedValue({ _id: "123", email: "test@example.com" });
    const user = {
      name: "Test User",
      email: "test@example.com",
      password: "password",
    };
    const response = await request.post("/auth/register").send(user);
    expect(User.findOne).toHaveBeenCalledWith({
      email: user.email
    });
    expect(response.status).toBe(400);
    expect(response.text).toBe("User already exists");
  });

  test("should create a new user and return token if registration is successful", async () => {
    User.findOne.mockResolvedValue(null);
    bcrypt.genSalt.mockResolvedValue("some-salt");
    bcrypt.hash.mockResolvedValue("hashed-password");
    const user = {
      name: "Test User",
      email: "test@example.com",
      password: "password",
    };
    const response = await request.post("/auth/register").send(user);
    expect(User.findOne).toHaveBeenCalledWith({
      email: user.email
    });
    expect(bcrypt.genSalt).toHaveBeenCalled();
    expect(bcrypt.hash).toHaveBeenCalledWith(user.password, "some-salt");
    expect(response.status).toBe(200);
    expect(response.body).toHaveProperty("token");
  });

  test("should return 500 if saving the user fails", async () => {
    User.findOne.mockResolvedValue(null);
    bcrypt.genSalt.mockResolvedValue("some-salt");
    bcrypt.hash.mockResolvedValue("hashed-password");
    User.prototype.save.mockRejectedValue(new Error("Save failed"));
    const user = {
      name: "Test User",
      email: "test@example.com",
      password: "password",
    };
    const response = await request.post("/auth/register").send(user);
    expect(response.status).toBe(500);
    expect(response.text).toBe("Server Error");
  });
});

